# Вариант 12. Оператор for в С.
Пример работы на выражении из [example.txt](exapmle.txt) можно увидеть в [graph.dot.svg](graph.dot.svg) 
## Грамматика

| Правило          | Описание                                                                                                                                                                        |
|------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| S -> FOR (A;B;C) | S - стартовый нетерминал, раскрывается в все итогове выражение.                                                                                                                 |
| FOR -> for       | Нетерминал для `for`.                                                                                                                                                           |
| A -> \epsilon    | Первое выражение может отсутствовать).                                                                                                                                          |
| A -> VV=N        | Раскрытие первого выражение в присваивание переменной. Пример: `int x = 1`.                                                                                                     |
| V -> *var*       | Терминал раскрывается в любую последовательность, которая может быть идентификатором (начинается с латинских буква или подчеркивания, дальше идут цифры, буквы и подчеркивания. |
| N -> *n*         | Раскрывается в число. Целое или нецелое.                                                                                                                                        |
| B -> VZN         | Раскрытие второго терминала в выражение со сравнение. Пример: `x < 10`.                                                                                                         |
| Z -> ==          | Раскрытие в знак сравнения на равенство.                                                                                                                                        |
| Z -> >E          | Раскрытие в больше или больше или равно.                                                                                                                                        |
| Z -> <E          | Раскрытие в меньше или меньше или равно.                                                                                                                                        |
| E -> \epsilon    | Терминал раскрывается в пустую строку, значит сравнение строгое.                                                                                                                |
| E -> =           | Сравнение нестрогое.                                                                                                                                                            |
| B -> \epsilon    | Второе выражение может отсутствовать.                                                                                                                                           |
| C -> \epsilon    | Третье выражение может отсутствовать.                                                                                                                                           |
| C -> VO          | Раскрытие третье выражение и инкремент или декремент.                                                                                                                           |
| O -> ++          | Инкремент.                                                                                                                                                                      |
| O -> --          | Декремент.                                                                                                                                                                      |      

Грамматика не может быть `LL(1)`, если имеет хвостовую рекурсию или правое ветвление. Но здесь такого нет, так что наша грамматика остается без изменений.

## ПЕРВ и СЛЕД
Для построения парсера нужно посчитать множества FIRST и FOLLOW (как и для проверки, что наша грамматика `LL(1)`).
Для этого я расписал их на бумажке и еще сделал программную реализацию (класс [GrammarAnalyser](src/main/java/com/github/smirnovdm2107/GrammarAnalyzer.java)).

| Нетерминал | FIRST     | FOLLOW               |
|------------|-----------|----------------------|
| A          | $, `var`  | ;                    |
| B          | $, `var`  | ;                    |
| S          | f         | $                    |
| C          | $, `var`  | )                    |
| E          | $, =      | n                    |
| F          | f         | (                    |
| V          | `var`     | `var`, +, <, =, -, > |
| Z          | <, =, >   | n                    |
| N          | `n`       | ;                    |
| O          | +, -      | )                    |

[Парсер](src/main/java/com/github/smirnovdm2107/Parser.java)

[Тесты](src/test/java/ParserTest.java)